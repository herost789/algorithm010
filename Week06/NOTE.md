学习笔记
### 动态规划：
	动态规划和递归或者分治没有根本上的区别(关键是看有无最优的子结构)
	共性：找到重复子问题
	差异性：最优子结构，中途可以淘汰次优解
	递归时加入缓存，提高性能，被称为记忆化搜索
	进行分治和记忆化。然后进行动态规划。高级阶段，自顶向下进行性动态规划
	状态转移方程
	opt[i,j]=opt[i+1,j]+opt[i,j+1]
	完整逻辑：
	if(a[i,j]=='空地') otp[i,j]=opt[i+1,j]+opt[i,j+1]
	else:opt[i,j]=0
	动态规划关键点：
		1.最优子结构opt[n]=best_of(opt[n-1],opt[n-2],...)
		2.储存中间状态：opt[i]
		3.递推公式(美其名曰：状态转移方程或者DP方程)
		Fib:opt[i]=opt[n-1]+opt[n-2]
		二维路径：opt[i,j]=opt[i+1][j]+opt[i][j+1](且判断a[i][j]是否是空地)
		uniquePaths
		最长公共子序列
		对于两个字符串，使用二维数组，一个在行上排下来，一个在列上排下来
		动态规划，定义出他的状态是很困难的，需要多加练习
		动态规划小结：
			1.打破自己的思维惯性，形成机器思维
			2.理解复杂逻辑的关键
			3.也是职业进阶的要点要领
			mit动态规划
	状态转移方程构造：
	    表示各个阶段所对应的状态
	    状态和行为有关
	    整个最值问题的结果可能直接是dp数据的最后一个元素
	    也有可能是dp数组的最值，需要结合题意以及dp[i]的含义分析