学习笔记
### 深度优先和广度优先
搜索--非智能搜索，是一种暴力搜索，本质是将所有的节
点都遍历一次且仅遍历一次。  
DFS使用模板进行编码，使用递归来编写。先写递归结束
的条件，然后写本次处理的逻辑，最后写下转。  
代码模板  
if node in visited return//递归终止条件，当节点
已经加入则返回，什么都不做   
visited.add(node)//当前层逻辑，就是将访问的节点
添加到已访问的集合中  
dfs(node.left)  
dfs(node.right)//下转，分别遍历左子树和右子树  
如果是图，就是联通的相邻节点，如果是多叉树，这里
就是对所有children节点进行递归  
深度优先遍历的顺序和前序遍历一致
BFS使用队列进行编码  
def BFS(graph,start,end)  
queue=[]  
queue.append([start])  
visited.add(start)  
while queue:  
      node=queue.pop()  
      visited.add(node)  
      process(node)  
      nodes=generate_related_nodes(node)  
      queue.push(nodes)
      
    

### 贪心算法
贪心算法是一种每一步选择中都采取在当前状态下最好或
最优(即最有利)的选择，从而希望全局的结果是最好或者
最优 

注意贪心算法与动态规划不同，贪心算法不能回退。  
动态规划则会保存以前的结果，并根据以前的结果对当前
进行选择，有回退功能  
贪心：当下做最优选择，无法回退
回溯：可以回退
动态规划：最优判断+回退
贪心法一般可以解决一些最优化的问题，如求图中的最小
树，求哈夫曼编码等。一旦一个问题可以使用贪心算法来
求解，那么贪心法是解决这个问题的最好办法。但是一般
工程或者生活中的问题，贪心法一般不能得到我们需要的
结果。由于贪心法的高效性及其所求答案比较接近最优结果
贪心法也可以用做辅助算法，或者直接解决一些要求结果不
特别精确的问题